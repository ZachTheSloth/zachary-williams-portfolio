<!DOCTYPE html>
<html>

<head>

	<title>Zachary Williams</title>

	<link rel="stylesheet" type="text/css" href="css/main.css">
    <link rel="stylesheet" type="text/css" href="css/project-article.css">

	<link href="https://fonts.googleapis.com/css?family=Rubik:700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700" rel="stylesheet">

</head>

<body>

	<div id="centering-container">

    	<div id="wrapper">

			<div id="tabs-area">
				<a href="index.html" id="selected-tab">Home</a>
				<a href="">Blog</a>
			</div>

            <div class="card" id="main-card">
				<div id="side-wrapper">
                	<img class="parallax main-image" src="assets/images/nikhedonia.PNG"><br>
					<a href="https://github.com/ZachTheSloth/NIKHEDONIA" class="button-parallax" class="call-to-action">View Code</a>
				</div>
				<div id="text-wrapper">
					<h1 id-"main-header">NIKHEDONIA</h1>
					<p>
						This project is an implementation of the board game 'Go' for iOS using Swift and and the SpriteKit framework. Go is a board game focused on surrounding enemy tiles to capture territory and remove the tiles from play. To accomplish this, I had to develop an algorithm to efficiently detect if a tile (or group of tiles) was fully surrounded, as well as implement the Model-View-Controller structure for simplicity. Using SpriteKit allowed me to take advantage of the sprite system to make logical 'tile' objects, as well as buttons and informational labels that could be easily animated.
						<br><br>
						The algorithm used to check for surrounded tiles works by iterating though every tile on the board. For each tile, the algorithm checks if any surrounding tiles are blank -- indicating that the current tile is not surrounded. If there are no blank tiles, it checks for surrounding tiles of the same color, to see if they are next to a blank tile. This continues until all connected tiles have been checked, or a blank tile has been found. The tiles that are deemed to be surrounded are then removed.
						<br><br>
						When working on this algorithm I ran into two major issues. The first issue had to do with the fact that when I determined a tile to be surrounded, I would remove it instantly. This would cause problems when checking the rest of the tiles on the board, because they would then consider the previously-removed tile as blank. To solve this, I would add each surrounded tile to an array, then iterate through it so they would all be removed at once.
						<br><br>
						The second major issue had to do with a special rule in Go. The rule states that even if a spot on the board is already surrounded, you can still place a piece there if it would result in one or more of the surrounding tiles to be removed. My algorithm initially did not account for that, so I had to adjust it. I solved this issue by first removing any surrounded tiles regardless of their effect, and then placing them down a second time before running the algorithm again. This meant that if a tile had no effect, it would get placed and removed twice â€” easy. If placing it down would result in other tiles being removed, however, it would remove them on the first pass and then successfully place the tile down during the second pass.
					</p>
				</div>
            </div>

    	</div>

	</div>

	<script type="text/javascript" src="js/vanilla-tilt.js"></script>
	<script type="text/javascript">

		VanillaTilt.init(document.querySelectorAll(".parallax"), {
			scale: 1.05,
			max: 13,
			glare: true,
			"max-glare": 0.25
		});

		VanillaTilt.init(document.querySelectorAll(".button-parallax"), {
			scale: 1.05,
			max: 0,
			glare: true,
			"max-glare": 0.5
		});

	</script>

</html>
